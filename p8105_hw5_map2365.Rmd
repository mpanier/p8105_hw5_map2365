---
title: "p8105_hw5_map2365"
output: github_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)

library(ggplot2)
library(tidyverse)
```

#Problem #1

*function that checks for duplicate birthdays*
```{r}
simulate_birthdays <- function(group_size) {
birthdays <- sample(1:365, group_size, replace = TRUE)
any(duplicated(birthdays))
}
```
*running the simulation for group sizes between 2 and 50. Note, I set the seed for reproducibility purposes.*
```{r}
set.seed(1123)
group_sizes <- 2:50
n_simulations <- 10000

probabilities <- numeric(length(group_sizes))

for (i in seq_along(group_sizes)) {
  group_size <- group_sizes[i]
  results <- replicate(n_simulations, simulate_birthdays(group_size))
  probabilities[i] <- mean(results)
}
```

*ploting the results*
```{r}
plot(group_sizes, probabilities, type = "b", 
     xlab = "Group Size (n)", 
     ylab = "Probability of Shared Birthday",
     main = "Probability of At Least Two People Sharing a Birthday",
     pch = 19, col = "blue")
```
*based on the plot, we can see that the probability of two people sharing a birthday increases as the size of the group increases. In fact, when the group size reaches 50, there is nearly the probability of 2 people sharing a birthday is nearly 100%*

#Problem 2
```{r}
# Set simulation parameters
n <- 30              # Sample size
sigma <- 5           # Standard deviation
alpha <- 0.05        # Significance level
n_simulations <- 5000  # Number of simulations per mean

# Define function to perform simulations for a given mean (mu)
simulate_for_mu <- function(mu) {
  # Initialize vectors to store results
  estimates <- numeric(n_simulations)
  p_values <- numeric(n_simulations)
  
  # Run simulations
  for (i in 1:n_simulations) {
    # Generate random sample
    data <- tibble::tibble(x = rnorm(n, mean = mu, sd = sigma))
    
    # Perform t-test and extract estimate and p-value
    t_test_result <- t.test(data$x, mu = 0)
    t_test_tidy <- broom::tidy(t_test_result)
    
    # Store results
    estimates[i] <- t_test_tidy$estimate
    p_values[i] <- t_test_tidy$p.value
  }
  
  # proportion of p-values less than alpha
  power <- mean(p_values < alpha)
  
  # average estimates
  avg_estimate_all <- mean(estimates)
  avg_estimate_rejected <- mean(estimates[p_values < alpha])
  
  # results as a list
  list(mu = mu,
       power = power,
       avg_estimate_all = avg_estimate_all,
       avg_estimate_rejected = avg_estimate_rejected)
}

# simulations for each value of mu in {0, 1, 2, 3, 4, 5, 6}
mu_values <- 0:6
results <- lapply(mu_values, simulate_for_mu)

# Convert results to a data frame
results_df <- bind_rows(lapply(results, as.data.frame))
```

*power vs. true mean (mu) plot*
```{r}
ggplot(results_df, aes(x = mu, y = power)) +
  geom_line() +
  geom_point() +
  labs(
    title = "Power of the One-Sample t-Test as a Function of True Mean (μ)",
    x = "True Mean (μ)",
    y = "Power"
  ) +
  theme_minimal()
```

*Plotting average estimate of mu_hat vs. true mean (mu)*
```{r}
ggplot(results_df, aes(x = mu)) +
  geom_line(aes(y = avg_estimate_all), color = "red") +
  geom_point(aes(y = avg_estimate_all), color = "red") +
  geom_line(aes(y = avg_estimate_rejected), color = "blue") +
  geom_point(aes(y = avg_estimate_rejected), color = "blue") +
  labs(
    title = "Average Estimate of μ̂ as a Function of True Mean (μ)",
    x = "True Mean (μ)",
    y = "Average Estimate of μ̂"
  ) +
  theme_minimal() +
  scale_color_manual(values = c("All Samples" = "red", "Rejected Null" = "blue")) +
  guides(color = guide_legend(title = "Estimate Type"))

```




